importScripts("./data/buffs.min.js","./data/gear.min.js","./data/races.min.js","./data/spells.min.js","./data/talents.min.js","./classes/player.min.js","./classes/simulation.min.js","./classes/spell.min.js","./classes/weapon.min.js","./globals.min.js","./WarriorSim.min.js"),onmessage=(e=>{const a=e.data;updateGlobals(a.globals),fetch("./WarriorSim.wasm").then(e=>e.arrayBuffer()).then(e=>WarriorSim({wasmBinary:e}).ready).then(e=>{const t=["head","neck","shoulder","back","chest","wrist","hands","waist","legs","feet","finger1","finger2","trinket1","trinket2","ranged","mainhand","offhand","twohand","custom"],r=[...Array(8)].map(()=>Math.floor(65536*Math.random()));e._initRandom(...r);for(let t of a.globals.buffs)e._enableBuff(t,1);for(let r in a.globals.enchant){const n=t.indexOf(r);for(let t of a.globals.enchant[r])t.selected&&e._enableEnchant(n,t.id,1)}for(let r in a.globals.gear){const n=t.indexOf(r);for(let t of a.globals.gear[r])t.selected&&e._enableItem(n,t.id,1)}function n(t,...r){const n=a.globals.rotation[t],i=e._spellOptions(n.id)>>2;e.HEAP32[i]=n.active?1:0,r.forEach((a,t)=>e.HEAP32[i+t+1]=n[a])}n(0,"minrage","reaction"),n(1,"minrage","reaction"),n(2,"minrage","maincd","unqueue","unqueuetimer","reaction"),n(4,"priorityap","reaction"),n(5,"minrage","maincd","reaction"),n(6,"timetoend","crusaders","reaction"),n(7,"timetoend","reaction"),n(9,"maxrage","maincd","reaction"),n(10,"timetoend","haste","reaction"),n(11,"timetoend","reaction"),n(12,"reaction"),n(13,"timetoend","crusaders","reaction"),n(16,"globals","reaction"),n(18,"minrage","reaction"),n(19,"minrage","unqueue","unqueuetimer","reaction");const i=e._allocConfig(),s=i>>2;e.HEAP32[s+0]=null!=a.player[0]?a.player[0]:-1,e.HEAP32[s+1]=null!=a.player[1]?"string"==typeof a.player[1]?t.indexOf(a.player[1]):a.player[1]:-1,e.HEAP32[s+2]=null!=a.player[2]?a.player[2]:-1,e.HEAP32[s+3]=["Human","Dwarf","Gnome","Night Elf","Orc","Tauren","Troll","Undead"].indexOf(a.player[3].race),e.HEAP32[s+4]=a.player[3].aqbooks?1:0,e.HEAP32[s+5]=a.player[3].weaponrng?1:0,e.HEAP32[s+6]=a.player[3].spelldamage,e.HEAP32[s+7]=a.player[3].target.level,e.HEAP32[s+8]=a.player[3].target.basearmor,e.HEAP32[s+9]=a.player[3].target.armor,e.HEAP32[s+10]=a.player[3].target.defense,e.HEAP32[s+11]=a.player[3].target.binaryresist,e.HEAPF64[s+12>>1]=a.player[3].target.mitigation,e.HEAP32[s+14]=a.sim.timesecsmin,e.HEAP32[s+15]=a.sim.timesecsmax,e.HEAP32[s+16]=a.sim.executeperc,e.HEAP32[s+17]=a.sim.startrage,e.HEAP32[s+18]=a.sim.iterations;const l=e._allocTalents();for(let a of talents)for(let t of a.t)t.c&&e._setTalent(l,t.i,t.c);const o=e._allocSimulation(i,l);e._runSimulation(o),e._reportSimulation(o,a.fullReport?1:0),e._freeSimulation(o),e._freeTalents(l),e._freeConfig(i)},e=>{console.error(e);const t=new Player(...a.player),r=new Simulation(t,e=>{a.fullReport&&(e.player=t.serializeStats(),e.spread=r.spread),postMessage([TYPE.FINISHED,e])},(e,a)=>{postMessage([TYPE.UPDATE,e,a])},a.sim);r.startSync()}).catch(e=>{postMessage([TYPE.ERROR,e])})});